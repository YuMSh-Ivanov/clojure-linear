# Линейная алгебра на Clojure.

Не беспокойтесь, знать линейную алгебру для выполнения этого ДЗ вам необязательно.

- Назовём _скаляром_ число.
- Назовём _вектором_ непустой массив чисел.
- Назовём _матрицей_ непустой массив векторов одинаковой длины.
- Говорят, что матрица имеет форму _M_ x _N_, если она состоит из _M_ векторов, каждый из которых имеет длину _N_.

В домашнем задании необходимо реализовать следующие функции:
- `v+` — сумма векторов. Поэлементно складывает ненулевое количество векторов одинаковой длины.
    ```clj
    (v+ [1 2 3] [4 5 6] [7 8 9] [10 11 12])
    ; => [22 26 30]
    (v+ [1 2])
    ; => [1 2]
    ```
- `v-` — разность векторов/отрицание вектора. Поэлементно вычитает/отрицает ненулевое количество векторов одинаковой длины.
    ```clj
    (v- [1 2 3] [4 5 6] [7 8 9] [10 11 12])
    ; => [-20 -22 -24]
    (v- [1 2])
    ; => [-1 -2]
    ```
- `v*` — покомпонентное произведение векторов. Поэлементно умножает ненулевое количество векторов одинаковой длины.
    ```clj
    (v* [1 2 3] [4 5 6] [7 8 9] [10 11 12])
    ; => [280 880 1944]
    (v* [1 2])
    ; => [1 2]
    ```
- `vd` — покомпонентное деление/обращение векторов. Поэлементно делит/обращает ненулевое количество векторов одинаковой длины.
    ```clj
    (vd [1 2 3] [4 5 6] [7 8 9] [10 11 12])
    ; => [1/280 1/220 1/216]
    (vd [1 2])
    ; => [1 1/2]
    ```
- `dot` — вариация на тему скалярного произведения. Возвращает сумму произведений компонент векторов одинаковой длины.
    ```clj
    (dot [1 2 3] [4 5 6] [7 8 9] [10 11 12])
    ; => 3104
    ; Пояснение: 1 * 4 * 7 * 10 + 2 * 5 * 8 * 11 + 3 * 6 * 9 * 12 => 3104
    (dot [1 2])
    ; => 3
    (dot)
    ; => 0
    ```
- `v*s` — умножение вектора на скаляр(ы). Принимает первым аргументов вектор, всеми остальными аргументами — скаляры. Возвращает вектор, компоненты которого умножены на произведение скаляров.
    ```clj
    (v*s [1 2 3 4] 5 6 7)
    ; => [210 420 630 840]
    (v*s [1 2 3])
    ; => [1 2 3]
    ```
- `m+` — сумма матриц. Поэлементно складывает ненулевое количество матриц одинаковой формы.
    ```clj
    (m+ [[1 2]
         [3 4]
         [5 6]]
        [[7 8]
         [9 10]
         [11 12]]
        [[13 14]
         [15 16]
         [17 18]])
    ; => [[21 24] [27 30] [33 36]]
    (m+ [[1 2 3]])
    ; => [[1 2 3]]
    (m+ [[1] [2] [3]])
    ; => [[1] [2] [3]]
    ```
- `m-` — разность/отрицание матриц. Поэлементно вычитает/отрицает ненулевое количество матриц одинаковой формы.
    ```clj
    (m- [[1 2]
         [3 4]
         [5 6]]
        [[7 8]
         [9 10]
         [11 12]]
        [[13 14]
         [15 16]
         [17 18]])
    ; => [[-19 -20] [-21 -22] [-23 -24]]
    (m- [[1 2 3]])
    ; => [[-1 -2 -3]]
    (m- [[1] [2] [3]])
    ; => [[-1] [-2] [-3]]
    ```
- `m*` — покомпонентное произведение матриц. Поэлементно умножает ненулевое количество матриц одинаковой формы.
    ```clj
    (m* [[1 2]
         [3 4]
         [5 6]]
        [[7 8]
         [9 10]
         [11 12]]
        [[13 14]
         [15 16]
         [17 18]])
    ; => [[91 224] [405 640] [935 1296]]
    (m* [[1 2 3]])
    ; => [[1 2 3]]
    (m* [[1] [2] [3]])
    ; => [[1] [2] [3]]
    ```
- `md` — покомпонентное деление/обращение матриц. Поэлементно делит/обращает ненулевое количество матриц одинаковой формы.
    ```clj
    (md [[1 2]
         [3 4]
         [5 6]]
        [[7 8]
         [9 10]
         [11 12]]
        [[13 14]
         [15 16]
         [17 18]])
    ; => [[1/91 1/56] [1/45 1/40] [5/187 1/36]]
    (md [[1 2 3]])
    ; => [[1 1/2 1/3]]
    (md [[1] [2] [3]])
    ; => [[1] [1/2] [1/3]]
    ```
- `m*s` — умножение матрицы на скаляр(ы). Принимает первым аргументов матрицу, всеми остальными аргументами — скаляры. Возвращает матрицу, элементы которой умножены на произведение скаляров.
    ```clj
    (m*s [[1 2 3 4] [5 6 7 8]] 9 10 11)
    ; => [[990 1980 2970 3960] [4950 5940 6930 7920]]
    (m*s [[1]])
    ; => [[1]]
    ```
- `transpose` — транспонирование матрицы. Принимает одну матрицу, меняет строки на столбцы (см. пример).
    ```clj
    (transpose [[1 2 3 4]
                [5 6 7 8]
                [9 10 11 12]])
    ; => [[1 5 9] [2 6 10] [3 7 11] [4 8 12]]
    (transpose [[1 2]
                [3 4]])
    ; => [[1 3] [2 4]]
    (transpose [[1 2]])
    ; => [[1] [2]]
    (transpose [[1]
                [2]])
    ; => [[1 2]]
    ```
- `m*v` — умножение матрицы на вектор-столбец. Принимает матрицу формы _M_ x _N_ и вектор длины _N_. Возвращает вектор размера _M_, каждый элемент которого равен скалярному произведению соответствующего вектора из матрицы и второго аргумента (см. пример).
    ```clj
    (m*v [[1 2 3]
          [4 5 6]]
         [100 10 1])
    ; => [123 456]
    ; Пояснение: [1 * 100 + 2 * 10 + 3 * 1,
    ;             4 * 100 + 5 * 10 + 6 * 1]
    (m*v [[1 2 3]] [100 10 1])
    ; => [123]
    ; Пояснение: [1 * 100 + 2 * 10 + 3 * 1]
    (m*v [[1] [2] [3]] [10])
    ; => [10 20 30]
    ; Пояснение: [1 * 10, 2 * 10, 3 * 10]
    ```
- `m*m` — произведение матриц. Принимает ненулевой набор матриц, перемножает их.\
    [Перемножение **двух** матриц](https://en.wikipedia.org/wiki/Matrix_multiplication) работает так: если _A_ — матрица формы _M_ x _N_, а _B_ — матрица формы _N_ x _R_, то _AB_ — матрица размера _M_ x _R_, элементами которой являются скалярные произведения строк из _A_ и столбцов из _B_ (см. пример).\
    ![Картинка](img/Matrix_multiplication_diagram_2.svg)\
    Утверждается, что такое произведение ассоциативно. Функция `m*m` принимает ненулевой набор матриц с размерами _N1_ x _N2_, _N2_ x _N3_, _N3_ x _N4_ и так далее, и должна посчитать произведение их всех.
    ```clj
    (m*m [[1 2]
          [3 4]
          [5 6]
          [7 8]]
         [[1000 100 10]
          [1 0.1 0.01]])
    ; => [[1002 100.2 10.02] [3004 300.4 30.04] [5006 500.6 50.06] [7008 700.8 70.08]]
    ; Пояснение: [[1 * 1000 + 2 * 1, 1 * 100 + 2 * 0.1, 1 * 10 + 2 * 0.01]
    ;             [3 * 1000 + 4 * 1, 3 * 100 + 4 * 0.1, 3 * 10 + 4 * 0.01]
    ;             [5 * 1000 + 6 * 1, 5 * 100 + 6 * 0.1, 5 * 10 + 6 * 0.01]
    ;             [7 * 1000 + 8 * 1, 7 * 100 + 8 * 0.1, 7 * 10 + 8 * 0.01]]
    ;
    ;            [[первая строка первой матрицы со всеми столбцами второй]
    ;             [вторая строка первой матрицы со всеми столбцами второй]
    ;             [третья строка первой матрицы со всеми столбцами второй]
    ;             [четвёртая строка первой матрицы со всеми столбцами второй]]
    (m*m [[1 2 3]
          [4 5 6]]
         [[100]
          [10]
          [1]])
    ; => [[123] [456]]
    (m*m [[1 2 3 4]] [[1000] [100] [10] [1]])
    ; => [[1234]]

    (m*m [[1 2 3] [4 5 6]])
    ; => [[1 2 3] [4 5 6]]

    (m*m [[1 2] [3 4] [5 6] [7 8]]
         [[1000 100 10] [1 0.1 0.01]]
         [[11] [22] [33]])
    ; => [[13557.06] [40644.12] [67731.18] [94818.24]]
    ; Пояснение: результат перемножения [[1 2] [3 4] [5 6] [7 8]] и [[1000 100 10] [1 0.1 0.01]] нам известен, а если умножить его на [[11] [22] [33]], получится [[13557.06] [40644.12] [67731.18] [94818.24]].
    ```

В процессе выполнения обратите внимание на применение функций высшего порядка и вынесение общего кода для операций.

### Сложный вариант.
Ко всем операциям должны быть прописаны контракты. Например, нельзя складывать вектора разной длины. Или транспонировать не-матрицу. Или перемножать матрицы неподходящей формы.
